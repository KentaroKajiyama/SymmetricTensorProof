笨・[3084/3084] Building SymmetricTensorProof.GraphEnumeration (68s)
trace: .> LEAN_PATH=C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\Cli\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\batteries\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\Qq\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\aesop\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\proofwidgets\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\importGraph\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\LeanSearchClient\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\plausible\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\packages\mathlib\.lake\build\lib\lean;C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\build\lib\lean c:\Users\jesus\.elan\toolchains\leanprover--lean4---v4.24.0-rc1\bin\lean.exe C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\SymmetricTensorProof\GraphEnumeration.lean -o C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\build\lib\lean\SymmetricTensorProof\GraphEnumeration.olean -i C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\build\lib\lean\SymmetricTensorProof\GraphEnumeration.ilean -c C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\build\ir\SymmetricTensorProof\GraphEnumeration.c --setup C:\Users\jesus\OneDrive\Documents\VScode\Repositories\research\SymmetricTensorProof\.lake\build\ir\SymmetricTensorProof\GraphEnumeration.setup.json --json
error: SymmetricTensorProof/GraphEnumeration.lean:106:62: unsolved goals
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
u v x y : V
竓｢ ((x = u 竏ｧ y = v 竏ｨ x = v 竏ｧ y = u) 竏ｨ G.Adj x y) 竏ｧ ﾂｬx = y 竊・G.Adj x y 竏ｨ x = u 竏ｧ y = v 竏ｨ x = v 竏ｧ y = u
warning: SymmetricTensorProof/GraphEnumeration.lean:109:8: This simp argument is unused:
  Set.mem_union

Hint: Omit it from the simp argument list.
  simp [Set.mem_uﾌｵnﾌｵiﾌｵoﾌｵnﾌｵ,ﾌｵ ﾌｵSﾌｵeﾌｵtﾌｵ.ﾌｵmﾌｵeﾌｵmﾌｵ_ﾌｵsingleton_iff]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: SymmetricTensorProof/GraphEnumeration.lean:109:23: This simp argument is unused:
  Set.mem_singleton_iff

Hint: Omit it from the simp argument list.
  simp [Set.mem_union,ﾌｵ ﾌｵSﾌｵeﾌｵtﾌｵ.ﾌｵmﾌｵeﾌｵmﾌｵ_ﾌｵsﾌｵiﾌｵnﾌｵgﾌｵlﾌｵeﾌｵtﾌｵoﾌｵnﾌｵ_ﾌｵiﾌｵfﾌｵfﾌｵ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
error: SymmetricTensorProof/GraphEnumeration.lean:127:6: Tactic `apply` failed: could not unify the conclusion of `@Iff.intro`
  (?a 竊・?b) 竊・(?b 竊・?a) 竊・(?a 竊・?b)
with the goal
  G.Adj x y 竊・ﾂｬx = y

Note: The full type of `@Iff.intro` is
  竏 {a b : Prop}, (a 竊・b) 竊・(b 竊・a) 竊・(a 竊・b)

case Adj.h.h.a
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
u v : V
h_neq : u 竕 v
h : G.Adj u v
this笨・: s(u, v) 竏・G.edgeSet
this : G.edgeSet 竏ｪ {s(u, v)} = G.edgeSet
x y : V
竓｢ G.Adj x y 竊・ﾂｬx = y
error: SymmetricTensorProof/GraphEnumeration.lean:133:20: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  fromEdgeSet (edgeSet ?G)
in the target expression
  (fromEdgeSet (G.edgeSet 竏ｪ {s(u, v)})).edgeSet = G.edgeSet 竏ｪ {s(u, v)}

V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
u v : V
h_neq : u 竕 v
h : ﾂｬG.Adj u v
竓｢ (fromEdgeSet (G.edgeSet 竏ｪ {s(u, v)})).edgeSet = G.edgeSet 竏ｪ {s(u, v)}
error: SymmetricTensorProof/GraphEnumeration.lean:146:8: Tactic `rewrite` failed: motive is not type correct:
  fun _a 竊ｦ _a.toFinset.card = G.edgeSet.toFinset.card + 1
Error: Application type mismatch: The argument
  (add_edge G u v).fintypeEdgeSet
has type
  Fintype 竊・add_edge G u v).edgeSet
but is expected to have type
  Fintype 竊狙a
in the application
  @Set.toFinset (Sym2 V) _a (add_edge G u v).fintypeEdgeSet

Explanation: The rewrite tactic rewrites an expression 'e' using an equality 'a = b' by the following process. First, it looks for all 'a' in 'e'. Second, it tries to abstract these occurrences of 'a' to create a function 'm := fun _a => ...', called the *motive*, with the property that 'm a' is definitionally equal to 'e'. Third, we observe that 'congrArg' implies that 'm a = m b', which can be used with lemmas such as 'Eq.mpr' to change the goal. However, if 'e' depends on specific properties of 'a', then the motive 'm' might not typecheck.

Possible solutions: use rewrite's 'occs' configuration option to limit which occurrences are rewritten, or use 'simp' or 'conv' mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and 'Decidable' instances whose types depend on the rewritten term, and 'simp' can apply user-defined '@[congr]' theorems as well).

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
u v : V
h_neq : u 竕 v
h : ﾂｬG.Adj u v
h_edgeSet : (add_edge G u v).edgeSet = G.edgeSet 竏ｪ {s(u, v)}
竓｢ (add_edge G u v).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
error: SymmetricTensorProof/GraphEnumeration.lean:168:23: Type mismatch
  h
has type
  x = v1 竏ｧ y = v1 竏ｨ G.Adj x y
but is expected to have type
  G.Adj x y
error: SymmetricTensorProof/GraphEnumeration.lean:169:24: Application type mismatch: The argument
  h
has type
  G.Adj x y
but is expected to have type
  x = v1 竏ｧ y = v1 竏ｨ G.Adj x y
in the application
  And.intro h
error: SymmetricTensorProof/GraphEnumeration.lean:179:8: No goals to be solved
error: SymmetricTensorProof/GraphEnumeration.lean:187:22: Type mismatch
  h_adj
has type
  G.Adj u x
but is expected to have type
  x = v1
error: SymmetricTensorProof/GraphEnumeration.lean:189:20: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  s(?m.210, ?m.211) = s(?m.212, ?m.213)
in the target expression
  u = v1 竏ｧ x = u 竏ｨ x = v1

case h.mp.inr.h
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u : V
h_max : MaxDegree4 (add_edge G v1 u)
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_eq : ﾂｬv1 = u
h_deg : (G.neighborSet u).toFinset.card = 4
h_adj_v1u : ﾂｬG.Adj v1 u
x : V
h_edge : u = v1 竏ｧ x = u 竏ｨ x = v1
竓｢ G.Adj u x
error: SymmetricTensorProof/GraphEnumeration.lean:193:30: Tactic `subst` failed: invalid equality proof, it is not of the form (x = t) or (t = x)
  G.Adj u x

case h.mpr.inr
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u : V
h_max : MaxDegree4 (add_edge G v1 u)
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_eq : ﾂｬv1 = u
h_deg : (G.neighborSet u).toFinset.card = 4
h_adj_v1u : ﾂｬG.Adj v1 u
x : V
h笨・: G.Adj u x
竓｢ G.Adj u x 竏ｨ u = v1 竏ｧ x = u 竏ｨ x = v1
error: SymmetricTensorProof/GraphEnumeration.lean:180:6: unsolved goals
case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u : V
h_max : MaxDegree4 (add_edge G v1 u)
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_eq : ﾂｬv1 = u
h_deg : (G.neighborSet u).toFinset.card = 4
h_adj_v1u : ﾂｬG.Adj v1 u
h_neighbors : (add_edge G v1 u).neighborSet u = G.neighborSet u 竏ｪ {v1}
竓｢ False
error: SymmetricTensorProof/GraphEnumeration.lean:172:2: unsolved goals
case neg.inr
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u : V
h_max : MaxDegree4 (add_edge G v1 u)
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_eq : ﾂｬv1 = u
h_adj : G.Adj v1 u
竓｢ False
error: SymmetricTensorProof/GraphEnumeration.lean:197:22: unexpected token '筺ｨ'; expected command
error: SymmetricTensorProof/GraphEnumeration.lean:286:59: Application type mismatch: The argument
  h_lhs
has type
  G.Adj (ﾏ・x) (ﾏ・y)
but is expected to have type
  G.Adj u_a y
in the application
  h_iso1_adj y h_lhs
error: SymmetricTensorProof/GraphEnumeration.lean:287:59: Application type mismatch: The argument
  h_lhs
has type
  G.Adj (ﾏ・x) (ﾏ・y)
but is expected to have type
  G.Adj u_b y
in the application
  h_iso2_adj y h_lhs
error: SymmetricTensorProof/GraphEnumeration.lean:291:35: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:291:35: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:299:33: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:299:33: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:306:35: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:306:35: Unknown identifier `h`
error: SymmetricTensorProof/GraphEnumeration.lean:258:58: unsolved goals
case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : x = u_a
hx2 : x = u_b
hy1 : ﾂｬy = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : x = u_a
hx2 : ﾂｬx = u_b
hy1 : y = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case pos
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : x = u_a
hx2 : ﾂｬx = u_b
hy1 : ﾂｬy = u_a
hy2 : y = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : x = u_a
hx2 : ﾂｬx = u_b
hy1 : ﾂｬy = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : x = u_b
hy1 : y = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case pos
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : x = u_b
hy1 : ﾂｬy = u_a
hy2 : y = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : x = u_b
hy1 : ﾂｬy = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case pos
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : ﾂｬx = u_b
hy1 : y = u_a
hy2 : y = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : ﾂｬx = u_b
hy1 : y = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case pos
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : ﾂｬx = u_b
hy1 : ﾂｬy = u_a
hy2 : y = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y

case neg
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 u_a u_b : V
anchors : List V
h_iso1 : (G.neighborSet u_a).toFinset.card = 0
h_iso2 : (G.neighborSet u_b).toFinset.card = 0
h_ne1 : u_a 竕 v1
h_ne2 : u_b 竕 v1
h_not_anchor1 : u_a 竏・anchors
h_not_anchor2 : u_b 竏・anchors
ﾏ・: Equiv.Perm V := Equiv.swap u_a u_b
h_iso_degree : 竏 (u : V), (G.neighborSet u).toFinset.card = 0 竊・竏 (v : V), ﾂｬG.Adj u v
h_iso1_adj : 竏 (v : V), ﾂｬG.Adj u_a v
h_iso2_adj : 竏 (v : V), ﾂｬG.Adj u_b v
h_ﾏダv : 竏 (v : V), v 竕 u_a 竊・v 竕 u_b 竊・ﾏ・v = v
h_anchors_fixed : 竏 a 竏・anchors, ﾏ・a = a
h_v1_fixed : ﾏ・v1 = v1
x y : V
hx1 : ﾂｬx = u_a
hx2 : ﾂｬx = u_b
hy1 : ﾂｬy = u_a
hy2 : ﾂｬy = u_b
竓｢ G.Adj (ﾏ・x) (ﾏ・y) 竊・G.Adj x y
error: SymmetricTensorProof/GraphEnumeration.lean:327:23: Type mismatch
  Equiv.swap_apply_right u_a u_b
has type
  (Equiv.swap u_a u_b) u_b = u_a
but is expected to have type
  ﾏ・u_a = u_b
error: SymmetricTensorProof/GraphEnumeration.lean:398:78: unsolved goals
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 : V
forbidden anchors : List V
candidates : List (SimpleGraph V) := generate_next_graphs G v1 forbidden
h_anchors_in_forbidden : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
u : V
h_u_not_forbidden : u 竏・forbidden
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_max : MaxDegree4 (add_edge G v1 u)
h_u_ne_v1 : u 竕 v1
h_not_adj : ﾂｬG.Adj v1 u
isolated_list : List V := {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso_def : isolated_list = {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
unused_list : List V :=
  {v |
      (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
        (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_unused_def :
  unused_list =
    {v |
        (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
          (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso : isolated_list = []
竓｢ generate_next_graphs G v1 forbidden = List.map (fun v 竊ｦ add_edge G v1 v) unused_list
error: SymmetricTensorProof/GraphEnumeration.lean:413:20: Tactic `rcases` failed: `h笨・: G.1 u x` is not an inductive datatype
error: SymmetricTensorProof/GraphEnumeration.lean:414:24: Tactic `subst` failed: invalid equality proof, it is not of the form (x = t) or (t = x)
  G.Adj u x

case h.mpr.inr
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 : V
forbidden anchors : List V
candidates : List (SimpleGraph V) := generate_next_graphs G v1 forbidden
h_anchors_in_forbidden : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
u : V
h_u_not_forbidden : u 竏・forbidden
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_max : MaxDegree4 (add_edge G v1 u)
h_u_ne_v1 : u 竕 v1
h_not_adj : ﾂｬG.Adj v1 u
isolated_list : List V := {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso_def : isolated_list = {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
unused_list : List V :=
  {v |
      (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
        (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_unused_def :
  unused_list =
    {v |
        (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
          (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso : isolated_list = []
h_cands : candidates = List.map (fun v 竊ｦ add_edge G v1 v) unused_list
h_bound : ((add_edge G v1 u).neighborSet u).toFinset.card 竕､ 4
x : V
h笨・: G.Adj u x
竓｢ G.Adj u x 竏ｨ u = v1 竏ｧ x = u 竏ｨ x = v1
error: SymmetricTensorProof/GraphEnumeration.lean:418:27: omega could not prove the goal:
a possible counterexample may satisfy the constraints
  c 竕･ 4
  0 竕､ b 竕､ 3
  a 竕･ 0
where
 a := 竊賎.edgeSet.toFinset.card
 b := 竊捜x | G.Adj u x}.card
 c := 竊・G.neighborSet u).toFinset.card
error: SymmetricTensorProof/GraphEnumeration.lean:419:14: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  @Disjoint (Finset ?m.474) Finset.partialOrder Finset.instOrderBot ?m.475 {?m.476}
in the target expression
  @Disjoint (Finset V) Finset.partialOrder Finset.instOrderBot (G.neighborSet u).toFinset {v1}.toFinset

V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 : V
forbidden anchors : List V
candidates : List (SimpleGraph V) := generate_next_graphs G v1 forbidden
h_anchors_in_forbidden : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
u : V
h_u_not_forbidden : u 竏・forbidden
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_max : MaxDegree4 (add_edge G v1 u)
h_u_ne_v1 : u 竕 v1
h_not_adj : ﾂｬG.Adj v1 u
isolated_list : List V := {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso_def : isolated_list = {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
unused_list : List V :=
  {v |
      (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
        (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_unused_def :
  unused_list =
    {v |
        (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
          (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso : isolated_list = []
h_cands : candidates = List.map (fun v 竊ｦ add_edge G v1 v) unused_list
h_bound : ((G.neighborSet u).toFinset 竏ｪ {v1}.toFinset).card 竕､ 4
h_neighbors : (add_edge G v1 u).neighborSet u = G.neighborSet u 竏ｪ {v1}
竓｢ Disjoint (G.neighborSet u).toFinset {v1}.toFinset
error: SymmetricTensorProof/GraphEnumeration.lean:434:105: unsolved goals
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 : V
forbidden anchors : List V
candidates : List (SimpleGraph V) := generate_next_graphs G v1 forbidden
h_anchors_in_forbidden : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
u : V
h_u_not_forbidden : u 竏・forbidden
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_max : MaxDegree4 (add_edge G v1 u)
h_u_ne_v1 : u 竕 v1
h_not_adj : ﾂｬG.Adj v1 u
isolated_list : List V := {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso_def : isolated_list = {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
unused_list : List V :=
  {v |
      (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
        (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_unused_def :
  unused_list =
    {v |
        (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
          (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
u_rep : V
rest : List V
h_iso : isolated_list = u_rep :: rest
竓｢ generate_next_graphs G v1 forbidden = add_edge G v1 u_rep :: List.map (fun v 竊ｦ add_edge G v1 v) unused_list
error: SymmetricTensorProof/GraphEnumeration.lean:442:67: Function expected at
  List.mem_cons_self
but this term has type
  ?m.619 竏・?m.619 :: ?m.620

Note: Expected a function because this term is being applied to the argument
  _
error: SymmetricTensorProof/GraphEnumeration.lean:473:24: Tactic `rcases` failed: `h笨・: G.1 u x` is not an inductive datatype
error: SymmetricTensorProof/GraphEnumeration.lean:474:28: Tactic `subst` failed: invalid equality proof, it is not of the form (x = t) or (t = x)
  G.Adj u x

case h.mpr.inr
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
G : SimpleGraph V
v1 : V
forbidden anchors : List V
candidates : List (SimpleGraph V) := generate_next_graphs G v1 forbidden
h_anchors_in_forbidden : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
u : V
h_u_not_forbidden : u 竏・forbidden
h_card : (add_edge G v1 u).edgeSet.toFinset.card = G.edgeSet.toFinset.card + 1
h_max : MaxDegree4 (add_edge G v1 u)
h_u_ne_v1 : u 竕 v1
h_not_adj : ﾂｬG.Adj v1 u
isolated_list : List V := {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_iso_def : isolated_list = {v | (G.neighborSet v).toFinset.card = 0 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
unused_list : List V :=
  {v |
      (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
        (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
h_unused_def :
  unused_list =
    {v |
        (G.neighborSet v).toFinset.card 竕･ 1 竏ｧ
          (G.neighborSet v).toFinset.card 竕､ 3 竏ｧ ﾂｬG.Adj v1 v 竏ｧ v 竕 v1 竏ｧ v 竏・forbidden}.toList
u_rep : V
rest : List V
h_iso : isolated_list = u_rep :: rest
h_cands : candidates = add_edge G v1 u_rep :: List.map (fun v 竊ｦ add_edge G v1 v) unused_list
h_u_iso : ﾂｬ(G.neighborSet u).toFinset.card = 0
h_bound : ((add_edge G v1 u).neighborSet u).toFinset.card 竕､ 4
x : V
h笨・: G.Adj u x
竓｢ G.Adj u x 竏ｨ u = v1 竏ｧ x = u 竏ｨ x = v1
warning: SymmetricTensorProof/GraphEnumeration.lean:364:28: This simp argument is unused:
  SimpleGraph.fromEdgeSet_edgeSet

Hint: Omit it from the simp argument list.
  simp only [add_edge, SﾌｵiﾌｵmﾌｵpﾌｵlﾌｵeﾌｵGﾌｵrﾌｵaﾌｵpﾌｵhﾌｵ.ﾌｵfﾌｵrﾌｵoﾌｵmﾌｵEﾌｵdﾌｵgﾌｵeﾌｵSﾌｵeﾌｵtﾌｵ_ﾌｵeﾌｵdﾌｵgﾌｵeﾌｵSﾌｵeﾌｵtﾌｵ,ﾌｵ ﾌｵSet.mem_union, Set.mem_singleton_iff]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: SymmetricTensorProof/GraphEnumeration.lean:364:61: This simp argument is unused:
  Set.mem_union

Hint: Omit it from the simp argument list.
  simp only [add_edge, SimpleGraph.fromEdgeSet_edgeSet, Set.mem_uﾌｵnﾌｵiﾌｵoﾌｵnﾌｵ,ﾌｵ ﾌｵSﾌｵeﾌｵtﾌｵ.ﾌｵmﾌｵeﾌｵmﾌｵ_ﾌｵsingleton_iff]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: SymmetricTensorProof/GraphEnumeration.lean:364:76: This simp argument is unused:
  Set.mem_singleton_iff

Hint: Omit it from the simp argument list.
  simp only [add_edge, SimpleGraph.fromEdgeSet_edgeSet, Set.mem_union,ﾌｵ ﾌｵSﾌｵeﾌｵtﾌｵ.ﾌｵmﾌｵeﾌｵmﾌｵ_ﾌｵsﾌｵiﾌｵnﾌｵgﾌｵlﾌｵeﾌｵtﾌｵoﾌｵnﾌｵ_ﾌｵiﾌｵfﾌｵfﾌｵ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: SymmetricTensorProof/GraphEnumeration.lean:367:15: This simp argument is unused:
  h_eq

Hint: Omit it from the simp argument list.
  simp ﾌｵ[ﾌｵhﾌｵ_ﾌｵeﾌｵqﾌｵ]ﾌｵ

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
error: SymmetricTensorProof/GraphEnumeration.lean:521:22: Invalid argument: Variable `G_prev` is not a proposition or let-declaration
error: SymmetricTensorProof/GraphEnumeration.lean:549:12: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  G_prev.Adj ?m.311 ?m.312
in the target expression
  ﾂｬG_S.Adj v1 u_S

V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
S : List (SimpleGraph V)
P_prev P_next : SimpleGraph V 竊・Prop
v1 : V
forbidden anchors : List V
h_prev_complete : complete_anchored_enumeration S P_prev anchors
h_step :
  竏 (G : SimpleGraph V),
    P_next G 竊・      竏・G_prev,
        P_prev G_prev 竏ｧ
          G.edgeSet.toFinset.card = G_prev.edgeSet.toFinset.card + 1 竏ｧ
            MaxDegree4 G 竏ｧ 竏・u 竏・forbidden, G = add_edge G_prev v1 u
h_anchors_cond : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = v1
h_v1_anchor : v1 竏・anchors
h_forbidden_sub : 竏 x 竏・forbidden, x 竏・anchors
G : SimpleGraph V
h_P_next : P_next G
G_prev : SimpleGraph V
h_prev : P_prev G_prev
h_card : G.edgeSet.toFinset.card = G_prev.edgeSet.toFinset.card + 1
h_max : MaxDegree4 G
u : V
h_u_not_forbidden : u 竏・forbidden
h_G_eq : G = add_edge G_prev v1 u
G_S : SimpleGraph V
h_S : G_S 竏・S
iso_prev : AnchoredIso G_prev G_S anchors
u_S : V := iso_prev.toEquiv u
G_S_next : SimpleGraph V := add_edge G_S v1 u_S
h_iso_v1 : iso_prev.toEquiv v1 = v1
ﾏ・: V 竕・V := iso_prev.toEquiv
h_G_S_next_iso : Nonempty (AnchoredIso G G_S_next anchors)
h_u_S_not_forbidden : u_S 竏・forbidden
竓｢ ﾂｬG_S.Adj v1 u_S
error: SymmetricTensorProof/GraphEnumeration.lean:580:71: Application type mismatch: The argument
  Eq.symm h_iso_v1
has type
  v1 = iso_prev.toEquiv v1
but is expected to have type
  u_S = ?m.345
in the application
  Eq.trans h_eq (Eq.symm h_iso_v1)
error: SymmetricTensorProof/GraphEnumeration.lean:594:33: Unknown identifier `v1`
error: SymmetricTensorProof/GraphEnumeration.lean:594:36: Unknown identifier `v1`
error: SymmetricTensorProof/GraphEnumeration.lean:597:13: Tactic `constructor` failed: target is not an inductive datatype

case Adj.h.h.a
V : Type u_1
inst笨敖ｹ : Fintype V
inst笨・: DecidableEq V
S : List (SimpleGraph V)
P_prev P_next : SimpleGraph V 竊・Prop
forbidden anchors : List V
h_prev_complete : complete_anchored_enumeration S P_prev anchors
h_forbidden_sub : 竏 x 竏・forbidden, x 竏・anchors
G : SimpleGraph V
h_P_next : P_next G
G_prev : SimpleGraph V
h_prev : P_prev G_prev
h_card : G.edgeSet.toFinset.card = G_prev.edgeSet.toFinset.card + 1
h_max : MaxDegree4 G
u : V
h_u_not_forbidden : u 竏・forbidden
G_S : SimpleGraph V
h_S : G_S 竏・S
iso_prev : AnchoredIso G_prev G_S anchors
u_S : V := iso_prev.toEquiv u
ﾏ・: V 竕・V := iso_prev.toEquiv
h_u_S_not_forbidden : u_S 竏・forbidden
h_step :
  竏 (G : SimpleGraph V),
    P_next G 竊・      竏・G_prev,
        P_prev G_prev 竏ｧ
          G.edgeSet.toFinset.card = G_prev.edgeSet.toFinset.card + 1 竏ｧ
            MaxDegree4 G 竏ｧ 竏・u_1 竏・forbidden, G = add_edge G_prev u u_1
h_anchors_cond : 竏 a 竏・anchors, a 竏・forbidden 竏ｨ a = u
h_v1_anchor : u 竏・anchors
h_G_eq : G = fromEdgeSet (G_prev.edgeSet 竏ｪ {s(u, u)})
G_S_next : SimpleGraph V := add_edge G_S u u_S
h_iso_v1 : iso_prev.toEquiv u = u
h_G_S_next_iso : Nonempty (AnchoredIso G G_S_next anchors)
h_not_adj : ﾂｬG_S.Adj u u_S
h_eq : u = u_S
h_u_v1 : u = u
a b : V
竓｢ a = sorry () 竊・b = sorry () 竊・G_prev.Adj a b
error: SymmetricTensorProof/GraphEnumeration.lean:615:12: Unknown constant `GraphEnumeration.AnchoredIso.max_degree_iff`
error: SymmetricTensorProof/GraphEnumeration.lean:618:8: No goals to be solved
error: SymmetricTensorProof/GraphEnumeration.lean:626:4: No goals to be solved
error: SymmetricTensorProof/GraphEnumeration.lean:637:10: Unknown constant `GraphEnumeration.AnchoredIso.trans`
error: Lean exited with code 1
Some required targets logged failures:
- SymmetricTensorProof.GraphEnumeration
error: build failed
